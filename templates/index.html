<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Todo Chatbot</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f6f2ea;
        --ink: #1e1b18;
        --brand: #1d7f68;
        --brand-dark: #145747;
        --panel: rgba(255, 255, 255, 0.78);
        --line: rgba(31, 29, 26, 0.12);
        --user: #e3f8f2;
        --bot: #fff7e5;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 8% 12%, #ffe6ae 0, transparent 30%),
          radial-gradient(circle at 90% 4%, #c9efe4 0, transparent 32%),
          linear-gradient(145deg, #f8f4ed, #f2efe7 45%, #e9f0ea);
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .orb {
        position: fixed;
        border-radius: 999px;
        filter: blur(48px);
        pointer-events: none;
        z-index: 0;
      }

      .orb.one {
        width: 280px;
        height: 280px;
        background: rgba(37, 183, 145, 0.22);
        top: -70px;
        right: 4vw;
      }

      .orb.two {
        width: 240px;
        height: 240px;
        background: rgba(255, 199, 89, 0.25);
        left: 4vw;
        bottom: -90px;
      }

      .shell {
        position: relative;
        z-index: 1;
        width: min(860px, 100%);
        height: min(760px, 88vh);
        border: 1px solid var(--line);
        border-radius: 20px;
        background: var(--panel);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: auto 1fr auto;
        overflow: hidden;
        box-shadow: 0 24px 58px rgba(35, 28, 18, 0.14);
      }

      .top {
        padding: 20px 22px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .title-wrap {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .badge {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        background: linear-gradient(145deg, #24a185, #176352);
        display: grid;
        place-items: center;
        color: white;
        font-weight: 700;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.05rem, 2vw, 1.35rem);
      }

      .hint {
        margin: 0;
        opacity: 0.75;
        font-size: 0.9rem;
      }

      .top-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .mode-pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.78rem;
        border: 1px solid var(--line);
        background: #f5f3ef;
      }

      .mode-pill.online {
        background: #ddf4ec;
        color: #0f5a49;
        border-color: rgba(15, 90, 73, 0.25);
      }

      .mode-pill.offline {
        background: #ffe6d7;
        color: #8a3c17;
        border-color: rgba(138, 60, 23, 0.25);
      }

      .messages {
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto;
      }

      .msg {
        max-width: 78%;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--line);
        white-space: pre-wrap;
        line-height: 1.35;
        animation: rise 180ms ease;
      }

      .msg a {
        color: #0b5ea8;
        text-decoration: underline;
        word-break: break-all;
      }

      .msg.user {
        margin-left: auto;
        background: var(--user);
      }

      .msg.bot {
        margin-right: auto;
        background: var(--bot);
      }

      .composer {
        border-top: 1px solid var(--line);
        padding: 14px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
      }

      input {
        width: 100%;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 12px;
        padding: 12px 14px;
        font: inherit;
      }

      input:focus {
        outline: 2px solid #89c8ba;
        outline-offset: 1px;
      }

      button {
        border: none;
        border-radius: 12px;
        padding: 0 18px;
        font: inherit;
        font-weight: 600;
        color: white;
        background: linear-gradient(145deg, var(--brand), var(--brand-dark));
        cursor: pointer;
      }

      button:hover {
        filter: brightness(1.05);
      }

      .mini-btn {
        height: 34px;
        padding: 0 12px;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 10px;
        font-size: 0.82rem;
        font-weight: 600;
      }

      .mini-select {
        height: 34px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        font: inherit;
        font-size: 0.82rem;
        padding: 0 10px;
      }

      .quick-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .quick-btn {
        height: 30px;
        padding: 0 12px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fffaf0;
        color: #2b2a28;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .smart-replies {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .smart-btn {
        height: 30px;
        padding: 0 12px;
        border-radius: 999px;
        border: 1px dashed rgba(29, 127, 104, 0.5);
        background: #ebfff8;
        color: #145747;
        font-size: 0.8rem;
        font-weight: 600;
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 12px;
        }

        .shell {
          height: min(760px, 95vh);
          border-radius: 16px;
        }

        .msg {
          max-width: 88%;
        }
      }
    </style>
  </head>
  <body>
    <div class="orb one"></div>
    <div class="orb two"></div>

    <main class="shell">
      <header class="top">
        <div class="title-wrap">
          <div class="badge">T</div>
          <div>
            <h1>Todo Chatbot</h1>
            <p class="hint">Try: add buy milk /p:high /d:2026-03-10</p>
          </div>
        </div>
        <div class="top-actions">
          <select id="language-select" class="mini-select">
            <option value="en-US|English">English</option>
            <option value="hi-IN|Hindi">Hindi</option>
            <option value="en-IN|Hinglish">Hinglish</option>
            <option value="es-ES|Spanish">Spanish</option>
          </select>
          <button id="mic-btn" class="mini-btn" type="button">Mic</button>
          <button id="voice-toggle-btn" class="mini-btn" type="button">Voice Off</button>
          <span id="mode-indicator" class="mode-pill online">Online</span>
          <button id="clear-chat-btn" class="mini-btn" type="button">Clear chat</button>
        </div>
      </header>

      <section id="messages" class="messages"></section>

      <footer class="composer">
        <form id="chat-form" class="row">
          <input
            id="chat-input"
            type="text"
            placeholder="Type a message..."
            autocomplete="off"
            required
          />
          <button id="send-btn" type="submit">Send</button>
        </form>
        <div class="quick-actions">
          <button type="button" class="quick-btn" data-prompt="help">help</button>
          <button type="button" class="quick-btn" data-prompt="list open">list open</button>
          <button type="button" class="quick-btn" data-prompt="stats">stats</button>
          <button
            type="button"
            class="quick-btn"
            data-prompt="suggest laptop under 800"
          >
            suggest laptop
          </button>
        </div>
        <div id="smart-replies" class="smart-replies"></div>
      </footer>
    </main>

    <script>
      const messagesEl = document.getElementById("messages");
      const formEl = document.getElementById("chat-form");
      const inputEl = document.getElementById("chat-input");
      const sendBtnEl = document.getElementById("send-btn");
      const modeIndicatorEl = document.getElementById("mode-indicator");
      const clearChatBtnEl = document.getElementById("clear-chat-btn");
      const languageSelectEl = document.getElementById("language-select");
      const micBtnEl = document.getElementById("mic-btn");
      const voiceToggleBtnEl = document.getElementById("voice-toggle-btn");
      const smartRepliesEl = document.getElementById("smart-replies");
      const quickBtns = document.querySelectorAll(".quick-btn");

      const OFFLINE_TODOS_KEY = "todo_chatbot_offline_todos_v1";
      const SESSION_KEY = "todo_chatbot_session_id_v1";
      const LANGUAGE_KEY = "todo_chatbot_language_v1";
      const VOICE_KEY = "todo_chatbot_voice_enabled_v1";
      const SERVER_UNREACHABLE_ERROR = "__SERVER_UNREACHABLE__";

      const savedLanguage = localStorage.getItem(LANGUAGE_KEY);
      if (savedLanguage && [...languageSelectEl.options].some((option) => option.value === savedLanguage)) {
        languageSelectEl.value = savedLanguage;
      }

      let isSending = false;
      let isListening = false;
      let shouldSubmitAfterListen = false;
      let offlineModeNotified = false;
      let recognition = null;
      let ttsEnabled = localStorage.getItem(VOICE_KEY) === "1";
      const sessionId = getOrCreateSessionId();
      const offlineTodos = loadOfflineTodos();

      function getOrCreateSessionId() {
        const existing = localStorage.getItem(SESSION_KEY);
        if (existing) return existing;
        const generated =
          typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        localStorage.setItem(SESSION_KEY, generated);
        return generated;
      }

      function getLanguageSetting() {
        const [speechCode, name] = (languageSelectEl.value || "en-US|English").split("|");
        return {
          speechCode: speechCode || "en-US",
          name: name || "English",
        };
      }

      function setConnectionMode(mode) {
        if (mode === "offline") {
          modeIndicatorEl.textContent = "Offline";
          modeIndicatorEl.classList.remove("online");
          modeIndicatorEl.classList.add("offline");
          return;
        }
        modeIndicatorEl.textContent = "Online";
        modeIndicatorEl.classList.remove("offline");
        modeIndicatorEl.classList.add("online");
      }

      function setVoiceToggleLabel() {
        voiceToggleBtnEl.textContent = ttsEnabled ? "Voice On" : "Voice Off";
      }

      function updateMicButton() {
        micBtnEl.textContent = isListening ? "Stop Mic" : "Mic";
      }

      function initSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          micBtnEl.disabled = true;
          micBtnEl.textContent = "Mic N/A";
          return;
        }

        recognition = new SpeechRecognition();
        recognition.lang = getLanguageSetting().speechCode;
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        recognition.continuous = false;

        recognition.onstart = () => {
          isListening = true;
          updateMicButton();
        };

        recognition.onresult = (event) => {
          const transcript = Array.from(event.results)
            .map((item) => item[0].transcript)
            .join(" ")
            .trim();
          inputEl.value = transcript;
        };

        recognition.onerror = () => {
          isListening = false;
          shouldSubmitAfterListen = false;
          updateMicButton();
        };

        recognition.onend = () => {
          isListening = false;
          updateMicButton();
          if (shouldSubmitAfterListen) {
            shouldSubmitAfterListen = false;
            if (inputEl.value.trim() && !isSending) {
              formEl.requestSubmit();
            }
          }
        };
      }

      function speakBotText(text) {
        if (!ttsEnabled) return;
        if (!("speechSynthesis" in window)) return;

        const spoken = text.replace(/https?:\/\/\S+/g, "").trim();
        if (!spoken) return;

        const utterance = new SpeechSynthesisUtterance(spoken);
        const language = getLanguageSetting().speechCode;
        utterance.lang = language;

        const voices = window.speechSynthesis.getVoices();
        const languageRoot = language.split("-")[0].toLowerCase();
        const matchingVoice = voices.find((voice) =>
          voice.lang.toLowerCase().startsWith(languageRoot)
        );
        if (matchingVoice) {
          utterance.voice = matchingVoice;
        }

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      }

      function normalizeOfflinePriority(rawValue) {
        const value = String(rawValue || "").trim().toLowerCase();
        if (["low", "medium", "high"].includes(value)) return value;
        return "medium";
      }

      function normalizeOfflineDueDate(rawValue) {
        const value = String(rawValue || "").trim();
        if (!value) return null;
        if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return null;
        const testDate = new Date(`${value}T00:00:00`);
        if (Number.isNaN(testDate.getTime())) return null;
        return value;
      }

      function loadOfflineTodos() {
        try {
          const raw = localStorage.getItem(OFFLINE_TODOS_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed
            .filter((item) => item && typeof item.text === "string")
            .map((item) => ({
              text: item.text.trim(),
              done: Boolean(item.done),
              priority: normalizeOfflinePriority(item.priority),
              due_date: normalizeOfflineDueDate(item.due_date),
            }))
            .filter((item) => item.text.length > 0);
        } catch {
          return [];
        }
      }

      function saveOfflineTodos() {
        try {
          localStorage.setItem(OFFLINE_TODOS_KEY, JSON.stringify(offlineTodos));
        } catch {
          // Ignore storage failures and keep chat available.
        }
      }

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function formatTextWithLinks(text) {
        const escaped = escapeHtml(text);
        const withLinks = escaped.replace(
          /(https?:\/\/[^\s]+)/g,
          '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
        );
        return withLinks.replaceAll("\n", "<br>");
      }

      function addMessage(role, text) {
        const message = document.createElement("div");
        message.className = `msg ${role}`;
        if (role === "bot") {
          message.innerHTML = formatTextWithLinks(text);
          speakBotText(text);
        } else {
          message.textContent = text;
        }
        messagesEl.appendChild(message);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function buildSmartReplies(botText, lastUserText = "") {
        const source = `${botText} ${lastUserText}`.toLowerCase();
        if (source.includes("online links for")) {
          return ["best budget option", "compare top 3", "suggest for students"];
        }
        if (source.includes("task stats")) {
          return ["list open", "list overdue", "add follow up /p:high"];
        }
        if (source.includes("no tasks yet")) {
          return ["add buy groceries /p:high", "help", "suggest laptop under 800"];
        }
        if (source.includes("invalid task number")) {
          return ["list", "help", "stats"];
        }
        if (source.includes("commands:")) {
          return ["add call client /p:high", "list open", "suggest headphones"];
        }
        return ["help", "list open", "stats"];
      }

      function renderSmartReplies(botText, lastUserText = "") {
        const suggestions = buildSmartReplies(botText, lastUserText);
        smartRepliesEl.innerHTML = "";
        suggestions.forEach((text) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "smart-btn";
          button.textContent = text;
          button.addEventListener("click", () => {
            if (isSending) return;
            inputEl.value = text;
            inputEl.focus();
            formEl.requestSubmit();
          });
          smartRepliesEl.appendChild(button);
        });
      }

      function resetChat() {
        messagesEl.innerHTML = "";
        const welcome = "Ready. Use voice, type, or tap suggestions.";
        addMessage("bot", welcome);
        renderSmartReplies(welcome);
      }

      clearChatBtnEl.addEventListener("click", () => {
        resetChat();
        inputEl.focus();
      });

      languageSelectEl.addEventListener("change", () => {
        localStorage.setItem(LANGUAGE_KEY, languageSelectEl.value);
        if (recognition) {
          recognition.lang = getLanguageSetting().speechCode;
        }
      });

      voiceToggleBtnEl.addEventListener("click", () => {
        ttsEnabled = !ttsEnabled;
        localStorage.setItem(VOICE_KEY, ttsEnabled ? "1" : "0");
        setVoiceToggleLabel();
      });

      micBtnEl.addEventListener("click", () => {
        if (!recognition) return;
        if (isListening) {
          shouldSubmitAfterListen = false;
          recognition.stop();
          return;
        }
        shouldSubmitAfterListen = true;
        recognition.lang = getLanguageSetting().speechCode;
        recognition.start();
      });

      quickBtns.forEach((button) => {
        button.addEventListener("click", () => {
          if (isSending) return;
          inputEl.value = button.dataset.prompt || "";
          inputEl.focus();
          formEl.requestSubmit();
        });
      });

      function extractProductQuery(text) {
        const trimmed = text.trim();
        const lower = trimmed.toLowerCase();
        const patterns = [
          /^(?:buy|get|purchase|order)\s+(.+)$/i,
          /^(?:recommend|suggest)\s+(?:me\s+)?(?:a|an|the\s+)?(.+)$/i,
          /^(?:best)\s+(.+)$/i,
          /^i\s+(?:want|need)\s+to\s+buy\s+(.+)$/i,
          /^what\s+is\s+the\s+best\s+(.+)$/i,
          /^which\s+(.+?)\s+should\s+i\s+buy\??$/i,
        ];

        for (const pattern of patterns) {
          const match = trimmed.match(pattern);
          if (!match || !match[1]) continue;
          const candidate = match[1].trim().replace(/[.?!]+$/, "");
          if (candidate) return candidate;
        }

        if (
          ["recommend", "suggest", "best", "buy", "purchase"].some((keyword) =>
            lower.includes(keyword)
          )
        ) {
          return trimmed
            .replace(/^(can you|please|hey|hi|hello|could you)\s+/i, "")
            .trim()
            .replace(/[.?!]+$/, "");
        }

        return null;
      }

      function buildProductLinks(query) {
        const encoded = encodeURIComponent(query);
        return [
          `Amazon: https://www.amazon.com/s?k=${encoded}`,
          `Walmart: https://www.walmart.com/search?q=${encoded}`,
          `Best Buy: https://www.bestbuy.com/site/searchpage.jsp?st=${encoded}`,
          `Target: https://www.target.com/s?searchTerm=${encoded}`,
        ];
      }

      function formatOfflineTodoLine(item, index) {
        const priority = normalizeOfflinePriority(item.priority).toUpperCase();
        const dueValue = normalizeOfflineDueDate(item.due_date);
        const dueSuffix = dueValue ? ` (due: ${dueValue})` : "";
        return `${index + 1}. [${item.done ? "x" : " "}] [${priority}] ${item.text}${dueSuffix}`;
      }

      function renderOfflineList(filterMode) {
        if (!offlineTodos.length) {
          return "No tasks yet. Add one with: add <task>";
        }

        const mode = (filterMode || "all").toLowerCase();
        const today = new Date().toISOString().slice(0, 10);

        const matches = offlineTodos
          .map((item, index) => ({ item, index }))
          .filter((entry) => {
            const item = entry.item;
            const done = Boolean(item.done);
            const priority = normalizeOfflinePriority(item.priority);
            const dueValue = normalizeOfflineDueDate(item.due_date);

            if (mode === "all") return true;
            if (mode === "open") return !done;
            if (mode === "done") return done;
            if (["low", "medium", "high"].includes(mode)) return priority === mode;
            if (mode === "today") return dueValue === today;
            if (mode === "overdue") return !done && Boolean(dueValue) && dueValue < today;
            return true;
          });

        if (!matches.length) {
          return `No tasks found for filter '${mode}'.`;
        }

        return matches
          .map((entry) => formatOfflineTodoLine(entry.item, entry.index))
          .join("\n");
      }

      function getOfflineReply(message) {
        const text = message.trim();
        const lower = text.toLowerCase();

        if (lower === "help" || lower === "commands") {
          return (
            "Commands:\n" +
            "- add <task> [/p:low|medium|high] [/d:YYYY-MM-DD]\n" +
            "- list [all|open|done|high|medium|low|today|overdue]\n" +
            "- done <number>\n" +
            "- undone <number>\n" +
            "- delete <number>\n\n" +
            "- priority <number> <low|medium|high>\n" +
            "- due <number> <YYYY-MM-DD|none>\n" +
            "- search <text>\n" +
            "- clear done\n" +
            "- clear all\n" +
            "- stats\n\n" +
            "Product queries:\n" +
            "- suggest laptop under 800\n" +
            "- best phone for gaming\n" +
            "- buy running shoes"
          );
        }

        const addMatch = text.match(/^(add|new|todo)\s+(.+)$/i);
        if (addMatch) {
          const rawTask = addMatch[2].trim();
          let priority = "medium";
          let dueDate = null;

          const priorityMatch = rawTask.match(/(?:^|\s)\/p:(low|medium|high)\b/i);
          if (priorityMatch) priority = priorityMatch[1].toLowerCase();

          const dueMatch = rawTask.match(/(?:^|\s)\/d:(\d{4}-\d{2}-\d{2}|none)\b/i);
          if (dueMatch) {
            const rawDue = dueMatch[1].toLowerCase();
            if (rawDue !== "none") {
              const normalizedDue = normalizeOfflineDueDate(rawDue);
              if (!normalizedDue) return "Invalid due date format. Use /d:YYYY-MM-DD";
              dueDate = normalizedDue;
            }
          }

          const cleanedTask = rawTask
            .replace(/(?:^|\s)\/p:(low|medium|high)\b/gi, " ")
            .replace(/(?:^|\s)\/d:(\d{4}-\d{2}-\d{2}|none)\b/gi, " ")
            .replace(/\s+/g, " ")
            .trim();

          if (!cleanedTask) {
            return (
              "Task text is required. Example:\n" +
              "add buy groceries /p:high /d:2026-03-10"
            );
          }

          offlineTodos.push({
            text: cleanedTask,
            done: false,
            priority,
            due_date: dueDate,
          });
          saveOfflineTodos();
          const extras = [`priority=${priority}`];
          if (dueDate) extras.push(`due=${dueDate}`);
          return `Added task #${offlineTodos.length}: ${cleanedTask} (${extras.join(", ")})`;
        }

        const listMatch = lower.match(
          /^(?:list|tasks|todos|show tasks|show todos)(?:\s+(all|open|done|high|medium|low|today|overdue))?$/
        );
        if (listMatch) return renderOfflineList(listMatch[1] || "all");

        const doneMatch = lower.match(/^(done|complete|finish)\s+(\d+)$/);
        if (doneMatch) {
          const index = Number(doneMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          offlineTodos[index - 1].done = true;
          saveOfflineTodos();
          return `Marked task #${index} as done.`;
        }

        const undoneMatch = lower.match(/^(undone|undo|reopen)\s+(\d+)$/);
        if (undoneMatch) {
          const index = Number(undoneMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          offlineTodos[index - 1].done = false;
          saveOfflineTodos();
          return `Marked task #${index} as not done.`;
        }

        const deleteMatch = lower.match(/^(delete|remove)\s+(\d+)$/);
        if (deleteMatch) {
          const index = Number(deleteMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const removed = offlineTodos.splice(index - 1, 1)[0];
          saveOfflineTodos();
          return `Deleted task #${index}: ${removed.text}`;
        }

        const priorityMatch = lower.match(
          /^(?:priority|set priority)\s+(\d+)\s+(low|medium|high)$/
        );
        if (priorityMatch) {
          const index = Number(priorityMatch[1]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const value = priorityMatch[2];
          offlineTodos[index - 1].priority = value;
          saveOfflineTodos();
          return `Updated priority of task #${index} to ${value}.`;
        }

        const dueMatch = lower.match(
          /^(?:due|set due)\s+(\d+)\s+(\d{4}-\d{2}-\d{2}|none)$/
        );
        if (dueMatch) {
          const index = Number(dueMatch[1]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const value = dueMatch[2];
          if (value === "none") {
            offlineTodos[index - 1].due_date = null;
            saveOfflineTodos();
            return `Removed due date from task #${index}.`;
          }
          const normalizedDue = normalizeOfflineDueDate(value);
          if (!normalizedDue) return "Invalid due date format. Use YYYY-MM-DD.";
          offlineTodos[index - 1].due_date = normalizedDue;
          saveOfflineTodos();
          return `Updated due date of task #${index} to ${normalizedDue}.`;
        }

        const searchMatch = text.match(/^(search|find)\s+(.+)$/i);
        if (searchMatch) {
          const query = searchMatch[2].trim().toLowerCase();
          if (!query) return "Please provide search text.";
          const rows = offlineTodos
            .map((item, index) => ({ item, index }))
            .filter((entry) => entry.item.text.toLowerCase().includes(query))
            .map((entry) => formatOfflineTodoLine(entry.item, entry.index));
          if (!rows.length) return "No matching tasks found.";
          return rows.join("\n");
        }

        if (["clear done", "clear completed", "remove done", "remove completed"].includes(lower)) {
          const before = offlineTodos.length;
          const remaining = offlineTodos.filter((item) => !item.done);
          offlineTodos.length = 0;
          offlineTodos.push(...remaining);
          saveOfflineTodos();
          return `Removed ${before - remaining.length} completed task(s).`;
        }

        if (["clear all", "reset", "delete all"].includes(lower)) {
          const count = offlineTodos.length;
          offlineTodos.length = 0;
          saveOfflineTodos();
          return `Cleared all tasks (${count}).`;
        }

        if (["stats", "summary"].includes(lower)) {
          const total = offlineTodos.length;
          const done = offlineTodos.filter((item) => item.done).length;
          const open = total - done;
          const high = offlineTodos.filter(
            (item) => normalizeOfflinePriority(item.priority) === "high"
          ).length;
          const today = new Date().toISOString().slice(0, 10);
          const overdue = offlineTodos.filter((item) => {
            const dueValue = normalizeOfflineDueDate(item.due_date);
            return !item.done && Boolean(dueValue) && dueValue < today;
          }).length;
          return (
            "Task stats:\n" +
            `- Total: ${total}\n` +
            `- Open: ${open}\n` +
            `- Done: ${done}\n` +
            `- High priority: ${high}\n` +
            `- Overdue (open): ${overdue}`
          );
        }

        const productQuery = extractProductQuery(text);
        if (productQuery) {
          return (
            `Online links for '${productQuery}':\n` +
            `${buildProductLinks(productQuery).map((line) => `- ${line}`).join("\n")}`
          );
        }

        if (["hi", "hello", "hey"].some((greeting) => lower.includes(greeting))) {
          return "Hi! I can manage todos. Try: add buy milk /p:high";
        }
        if (lower.includes("name")) return "I am your Todo Chatbot.";
        if (lower.includes("how are you")) return "Doing well. Want to add a task?";

        return (
          "I can help with todos and product links. Use:\n" +
          "- add <task> [/p:high] [/d:YYYY-MM-DD]\n" +
          "- list [open|done|today|overdue]\n" +
          "- done <number>\n" +
          "- undone <number>\n" +
          "- delete <number>\n" +
          "- priority <number> <low|medium|high>\n" +
          "- due <number> <YYYY-MM-DD|none>\n" +
          "- search <text>\n" +
          "- clear done\n" +
          "- clear all\n" +
          "- stats\n" +
          "- suggest <product>"
        );
      }

      function buildApiEndpoints() {
        const endpoints = ["/api/chat"];
        const protocol = window.location.protocol;
        const host = window.location.hostname || "";

        if (
          protocol === "http:" &&
          (host === "127.0.0.1" || host === "localhost")
        ) {
          endpoints.push(`http://${host}:5000/api/chat`);
        }

        if (protocol !== "https:") {
          endpoints.push("http://127.0.0.1:5000/api/chat");
          endpoints.push("http://localhost:5000/api/chat");
        }

        return Array.from(new Set(endpoints));
      }

      async function parseResponse(response) {
        const contentType = response.headers.get("content-type") || "";
        const rawText = await response.text();
        if (contentType.includes("application/json")) {
          try {
            return { payload: JSON.parse(rawText || "{}"), plainText: "" };
          } catch {
            return { payload: {}, plainText: rawText.trim() };
          }
        }
        return { payload: {}, plainText: rawText.trim() };
      }

      async function sendToEndpoint(endpoint, message, activeSessionId, languageName) {
        const query = new URLSearchParams({
          message,
          session_id: activeSessionId,
          language: languageName,
        });
        const getResponse = await fetch(`${endpoint}?${query.toString()}`);

        let response = getResponse;
        if (getResponse.status === 405) {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message,
              session_id: activeSessionId,
              language: languageName,
            }),
          });
        }

        const parsed = await parseResponse(response);
        return { response, ...parsed };
      }

      function looksLikeMissingApi(errorText) {
        const text = (errorText || "").toLowerCase();
        return (
          text.includes("cannot get /api/chat") ||
          text.includes("cannot post /api/chat")
        );
      }

      async function sendMessage(message) {
        const endpoints = buildApiEndpoints();
        const languageName = getLanguageSetting().name;
        let lastError = null;
        let sawUnreachableServer = false;

        for (const endpoint of endpoints) {
          try {
            const { response, payload, plainText } = await sendToEndpoint(
              endpoint,
              message,
              sessionId,
              languageName
            );

            if (response.ok && typeof payload.reply === "string") {
              return payload.reply;
            }

            const errorText =
              payload.error || plainText || `Request failed (${response.status})`;

            if (
              response.status === 404 ||
              response.status === 405 ||
              looksLikeMissingApi(errorText)
            ) {
              sawUnreachableServer = true;
              lastError = new Error(errorText);
              continue;
            }

            throw new Error(errorText);
          } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            const text = lastError.message.toLowerCase();
            if (
              text.includes("failed to fetch") ||
              text.includes("networkerror") ||
              text.includes("load failed")
            ) {
              sawUnreachableServer = true;
            }
          }
        }

        if (sawUnreachableServer) {
          throw new Error(SERVER_UNREACHABLE_ERROR);
        }
        if (lastError) {
          throw lastError;
        }
        throw new Error(SERVER_UNREACHABLE_ERROR);
      }

      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (isSending) return;

        const message = inputEl.value.trim();
        if (!message) return;

        isSending = true;
        inputEl.disabled = true;
        sendBtnEl.disabled = true;
        sendBtnEl.textContent = "Sending...";

        inputEl.value = "";
        addMessage("user", message);

        try {
          const reply = await sendMessage(message);
          setConnectionMode("online");
          offlineModeNotified = false;
          addMessage("bot", reply);
          renderSmartReplies(reply, message);
        } catch (error) {
          if (error instanceof Error && error.message === SERVER_UNREACHABLE_ERROR) {
            setConnectionMode("offline");
            if (!offlineModeNotified) {
              addMessage(
                "bot",
                "Server not reachable. Switched to offline mode. " +
                  "Run python app.py and open http://127.0.0.1:5000 for full mode."
              );
              offlineModeNotified = true;
            }
            const offlineReply = getOfflineReply(message);
            addMessage("bot", offlineReply);
            renderSmartReplies(offlineReply, message);
          } else {
            const text = error instanceof Error ? error.message : String(error);
            addMessage("bot", `Error: ${text}`);
          }
        } finally {
          isSending = false;
          inputEl.disabled = false;
          sendBtnEl.disabled = false;
          sendBtnEl.textContent = "Send";
          inputEl.focus();
        }
      });

      setConnectionMode("online");
      setVoiceToggleLabel();
      initSpeechRecognition();
      updateMicButton();
      resetChat();
    </script>
  </body>
</html>
