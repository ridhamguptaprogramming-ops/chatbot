<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Todo Chatbot</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f6f2ea;
        --ink: #1e1b18;
        --brand: #1d7f68;
        --brand-dark: #145747;
        --panel: rgba(255, 255, 255, 0.78);
        --line: rgba(31, 29, 26, 0.12);
        --user: #e3f8f2;
        --bot: #fff7e5;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 8% 12%, #ffe6ae 0, transparent 30%),
          radial-gradient(circle at 90% 4%, #c9efe4 0, transparent 32%),
          linear-gradient(145deg, #f8f4ed, #f2efe7 45%, #e9f0ea);
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .orb {
        position: fixed;
        border-radius: 999px;
        filter: blur(48px);
        pointer-events: none;
        z-index: 0;
      }

      .orb.one {
        width: 280px;
        height: 280px;
        background: rgba(37, 183, 145, 0.22);
        top: -70px;
        right: 4vw;
      }

      .orb.two {
        width: 240px;
        height: 240px;
        background: rgba(255, 199, 89, 0.25);
        left: 4vw;
        bottom: -90px;
      }

      .shell {
        position: relative;
        z-index: 1;
        width: min(860px, 100%);
        height: min(760px, 88vh);
        border: 1px solid var(--line);
        border-radius: 20px;
        background: var(--panel);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: auto 1fr auto;
        overflow: hidden;
        box-shadow: 0 24px 58px rgba(35, 28, 18, 0.14);
      }

      .top {
        padding: 20px 22px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .title-wrap {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .badge {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        background: linear-gradient(145deg, #24a185, #176352);
        display: grid;
        place-items: center;
        color: white;
        font-weight: 700;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.05rem, 2vw, 1.35rem);
      }

      .hint {
        margin: 0;
        opacity: 0.75;
        font-size: 0.9rem;
      }

      .top-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .mode-pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.78rem;
        border: 1px solid var(--line);
        background: #f5f3ef;
      }

      .mode-pill.online {
        background: #ddf4ec;
        color: #0f5a49;
        border-color: rgba(15, 90, 73, 0.25);
      }

      .mode-pill.offline {
        background: #ffe6d7;
        color: #8a3c17;
        border-color: rgba(138, 60, 23, 0.25);
      }

      .messages {
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto;
      }

      .msg {
        max-width: 78%;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--line);
        white-space: pre-wrap;
        line-height: 1.35;
        animation: rise 180ms ease;
      }

      .msg a {
        color: #0b5ea8;
        text-decoration: underline;
        word-break: break-all;
      }

      .msg.user {
        margin-left: auto;
        background: var(--user);
      }

      .msg.bot {
        margin-right: auto;
        background: var(--bot);
      }

      .composer {
        border-top: 1px solid var(--line);
        padding: 14px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
      }

      input {
        width: 100%;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 12px;
        padding: 12px 14px;
        font: inherit;
      }

      input:focus {
        outline: 2px solid #89c8ba;
        outline-offset: 1px;
      }

      button {
        border: none;
        border-radius: 12px;
        padding: 0 18px;
        font: inherit;
        font-weight: 600;
        color: white;
        background: linear-gradient(145deg, var(--brand), var(--brand-dark));
        cursor: pointer;
      }

      button:hover {
        filter: brightness(1.05);
      }

      .mini-btn {
        height: 34px;
        padding: 0 12px;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 10px;
        font-size: 0.82rem;
        font-weight: 600;
      }

      .quick-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .quick-btn {
        height: 30px;
        padding: 0 12px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fffaf0;
        color: #2b2a28;
        font-size: 0.8rem;
        font-weight: 600;
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 12px;
        }

        .shell {
          height: min(760px, 95vh);
          border-radius: 16px;
        }

        .msg {
          max-width: 88%;
        }
      }
    </style>
  </head>
  <body>
    <div class="orb one"></div>
    <div class="orb two"></div>

    <main class="shell">
      <header class="top">
        <div class="title-wrap">
          <div class="badge">T</div>
          <div>
            <h1>Todo Chatbot</h1>
            <p class="hint">Try: add buy milk, stats, suggest laptop under 800</p>
          </div>
        </div>
        <div class="top-actions">
          <span id="mode-indicator" class="mode-pill online">Online</span>
          <button id="clear-chat-btn" class="mini-btn" type="button">Clear chat</button>
        </div>
      </header>

      <section id="messages" class="messages"></section>

      <footer class="composer">
        <form id="chat-form" class="row">
          <input
            id="chat-input"
            type="text"
            placeholder="Type a message..."
            autocomplete="off"
            required
          />
          <button id="send-btn" type="submit">Send</button>
        </form>
        <div class="quick-actions">
          <button type="button" class="quick-btn" data-prompt="help">help</button>
          <button type="button" class="quick-btn" data-prompt="list">list</button>
          <button type="button" class="quick-btn" data-prompt="stats">stats</button>
          <button
            type="button"
            class="quick-btn"
            data-prompt="suggest laptop under 800"
          >
            suggest laptop
          </button>
        </div>
      </footer>
    </main>

    <script>
      const messagesEl = document.getElementById("messages");
      const formEl = document.getElementById("chat-form");
      const inputEl = document.getElementById("chat-input");
      const sendBtnEl = document.getElementById("send-btn");
      const modeIndicatorEl = document.getElementById("mode-indicator");
      const clearChatBtnEl = document.getElementById("clear-chat-btn");
      const quickBtns = document.querySelectorAll(".quick-btn");
      const OFFLINE_TODOS_KEY = "todo_chatbot_offline_todos_v1";
      const SERVER_UNREACHABLE_ERROR = "__SERVER_UNREACHABLE__";

      let isSending = false;
      let offlineModeNotified = false;
      const offlineTodos = loadOfflineTodos();

      function loadOfflineTodos() {
        try {
          const raw = localStorage.getItem(OFFLINE_TODOS_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed
            .filter((item) => item && typeof item.text === "string")
            .map((item) => ({
              text: item.text.trim(),
              done: Boolean(item.done),
            }))
            .filter((item) => item.text.length > 0);
        } catch {
          return [];
        }
      }

      function saveOfflineTodos() {
        try {
          localStorage.setItem(OFFLINE_TODOS_KEY, JSON.stringify(offlineTodos));
        } catch {
          // Ignore storage failures and keep chat available.
        }
      }

      function setConnectionMode(mode) {
        if (mode === "offline") {
          modeIndicatorEl.textContent = "Offline";
          modeIndicatorEl.classList.remove("online");
          modeIndicatorEl.classList.add("offline");
          return;
        }
        modeIndicatorEl.textContent = "Online";
        modeIndicatorEl.classList.remove("offline");
        modeIndicatorEl.classList.add("online");
      }

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function formatTextWithLinks(text) {
        const escaped = escapeHtml(text);
        const withLinks = escaped.replace(
          /(https?:\/\/[^\s]+)/g,
          '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
        );
        return withLinks.replaceAll("\n", "<br>");
      }

      function addMessage(role, text) {
        const message = document.createElement("div");
        message.className = `msg ${role}`;
        if (role === "bot") {
          message.innerHTML = formatTextWithLinks(text);
        } else {
          message.textContent = text;
        }
        messagesEl.appendChild(message);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function resetChat() {
        messagesEl.innerHTML = "";
        addMessage("bot", "Ready. Use 'help' to see commands.");
      }

      clearChatBtnEl.addEventListener("click", () => {
        resetChat();
        inputEl.focus();
      });

      quickBtns.forEach((button) => {
        button.addEventListener("click", () => {
          if (isSending) return;
          inputEl.value = button.dataset.prompt || "";
          inputEl.focus();
          formEl.requestSubmit();
        });
      });

      function extractProductQuery(text) {
        const trimmed = text.trim();
        const lower = trimmed.toLowerCase();
        const patterns = [
          /^(?:buy|get|purchase|order)\s+(.+)$/i,
          /^(?:recommend|suggest)\s+(?:me\s+)?(?:a|an|the\s+)?(.+)$/i,
          /^(?:best)\s+(.+)$/i,
          /^i\s+(?:want|need)\s+to\s+buy\s+(.+)$/i,
          /^what\s+is\s+the\s+best\s+(.+)$/i,
          /^which\s+(.+?)\s+should\s+i\s+buy\??$/i,
        ];

        for (const pattern of patterns) {
          const match = trimmed.match(pattern);
          if (!match || !match[1]) continue;
          const candidate = match[1].trim().replace(/[.?!]+$/, "");
          if (candidate) return candidate;
        }

        if (
          ["recommend", "suggest", "best", "buy", "purchase"].some((keyword) =>
            lower.includes(keyword)
          )
        ) {
          return trimmed
            .replace(/^(can you|please|hey|hi|hello|could you)\s+/i, "")
            .trim()
            .replace(/[.?!]+$/, "");
        }

        return null;
      }

      function buildProductLinks(query) {
        const encoded = encodeURIComponent(query);
        return [
          `Amazon: https://www.amazon.com/s?k=${encoded}`,
          `Walmart: https://www.walmart.com/search?q=${encoded}`,
          `Best Buy: https://www.bestbuy.com/site/searchpage.jsp?st=${encoded}`,
          `Target: https://www.target.com/s?searchTerm=${encoded}`,
        ];
      }

      function getOfflineReply(message) {
        const text = message.trim();
        const lower = text.toLowerCase();

        if (lower === "help" || lower === "commands") {
          return (
            "Commands:\n" +
            "- add <task>\n" +
            "- list\n" +
            "- done <number>\n" +
            "- undone <number>\n" +
            "- delete <number>\n\n" +
            "- clear done\n" +
            "- clear all\n" +
            "- stats\n\n" +
            "Product queries:\n" +
            "- suggest laptop under 800\n" +
            "- best phone for gaming\n" +
            "- buy running shoes"
          );
        }

        const addMatch = text.match(/^(add|new|todo)\s+(.+)$/i);
        if (addMatch) {
          const task = addMatch[2].trim();
          offlineTodos.push({ text: task, done: false });
          saveOfflineTodos();
          return `Added task #${offlineTodos.length}: ${task}`;
        }

        if (
          ["list", "tasks", "todos", "show tasks", "show todos"].includes(lower)
        ) {
          if (!offlineTodos.length) {
            return "No tasks yet. Add one with: add <task>";
          }
          return offlineTodos
            .map(
              (item, index) =>
                `${index + 1}. [${item.done ? "x" : " "}] ${item.text}`
            )
            .join("\n");
        }

        const doneMatch = lower.match(/^(done|complete|finish)\s+(\d+)$/);
        if (doneMatch) {
          const index = Number(doneMatch[2]);
          if (index < 1 || index > offlineTodos.length) {
            return "Invalid task number.";
          }
          offlineTodos[index - 1].done = true;
          saveOfflineTodos();
          return `Marked task #${index} as done.`;
        }

        const undoneMatch = lower.match(/^(undone|undo|reopen)\s+(\d+)$/);
        if (undoneMatch) {
          const index = Number(undoneMatch[2]);
          if (index < 1 || index > offlineTodos.length) {
            return "Invalid task number.";
          }
          offlineTodos[index - 1].done = false;
          saveOfflineTodos();
          return `Marked task #${index} as not done.`;
        }

        const deleteMatch = lower.match(/^(delete|remove)\s+(\d+)$/);
        if (deleteMatch) {
          const index = Number(deleteMatch[2]);
          if (index < 1 || index > offlineTodos.length) {
            return "Invalid task number.";
          }
          const removed = offlineTodos.splice(index - 1, 1)[0];
          saveOfflineTodos();
          return `Deleted task #${index}: ${removed.text}`;
        }

        if (["clear done", "clear completed", "remove done", "remove completed"].includes(lower)) {
          const before = offlineTodos.length;
          const remaining = offlineTodos.filter((item) => !item.done);
          offlineTodos.length = 0;
          offlineTodos.push(...remaining);
          saveOfflineTodos();
          return `Removed ${before - remaining.length} completed task(s).`;
        }

        if (["clear all", "reset", "delete all"].includes(lower)) {
          const count = offlineTodos.length;
          offlineTodos.length = 0;
          saveOfflineTodos();
          return `Cleared all tasks (${count}).`;
        }

        if (["stats", "summary"].includes(lower)) {
          const total = offlineTodos.length;
          const done = offlineTodos.filter((item) => item.done).length;
          const open = total - done;
          return `Task stats:\n- Total: ${total}\n- Open: ${open}\n- Done: ${done}`;
        }

        const productQuery = extractProductQuery(text);
        if (productQuery) {
          return (
            `Online links for '${productQuery}':\n` +
            `${buildProductLinks(productQuery).map((line) => `- ${line}`).join("\n")}`
          );
        }

        if (["hi", "hello", "hey"].some((greeting) => lower.includes(greeting))) {
          return "Hi! I can manage todos. Try: add buy milk";
        }
        if (lower.includes("name")) {
          return "I am your Todo Chatbot.";
        }
        if (lower.includes("how are you")) {
          return "Doing well. Want to add a task?";
        }

        return (
          "I can help with todos and product links. Use:\n" +
          "- add <task>\n" +
          "- list\n" +
          "- done <number>\n" +
          "- undone <number>\n" +
          "- delete <number>\n" +
          "- clear done\n" +
          "- clear all\n" +
          "- stats\n" +
          "- suggest <product>"
        );
      }

      function buildApiEndpoints() {
        const endpoints = ["/api/chat"];
        const protocol = window.location.protocol;
        const host = window.location.hostname || "";

        if (
          protocol === "http:" &&
          (host === "127.0.0.1" || host === "localhost")
        ) {
          endpoints.push(`http://${host}:5000/api/chat`);
        }

        if (protocol !== "https:") {
          endpoints.push("http://127.0.0.1:5000/api/chat");
          endpoints.push("http://localhost:5000/api/chat");
        }

        return Array.from(new Set(endpoints));
      }

      async function parseResponse(response) {
        const contentType = response.headers.get("content-type") || "";
        const rawText = await response.text();
        if (contentType.includes("application/json")) {
          try {
            return { payload: JSON.parse(rawText || "{}"), plainText: "" };
          } catch {
            return { payload: {}, plainText: rawText.trim() };
          }
        }
        return { payload: {}, plainText: rawText.trim() };
      }

      async function sendToEndpoint(endpoint, message) {
        const getResponse = await fetch(
          `${endpoint}?message=${encodeURIComponent(message)}`
        );

        let response = getResponse;
        if (getResponse.status === 405) {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ message }),
          });
        }

        const parsed = await parseResponse(response);
        return { response, ...parsed };
      }

      function looksLikeMissingApi(errorText) {
        const text = (errorText || "").toLowerCase();
        return (
          text.includes("cannot get /api/chat") ||
          text.includes("cannot post /api/chat")
        );
      }

      async function sendMessage(message) {
        const endpoints = buildApiEndpoints();
        let lastError = null;
        let sawUnreachableServer = false;

        for (const endpoint of endpoints) {
          try {
            const { response, payload, plainText } = await sendToEndpoint(
              endpoint,
              message
            );

            if (response.ok && typeof payload.reply === "string") {
              return payload.reply;
            }

            const errorText =
              payload.error || plainText || `Request failed (${response.status})`;

            if (
              response.status === 404 ||
              response.status === 405 ||
              looksLikeMissingApi(errorText)
            ) {
              sawUnreachableServer = true;
              lastError = new Error(errorText);
              continue;
            }

            throw new Error(errorText);
          } catch (error) {
            lastError =
              error instanceof Error ? error : new Error(String(error));

            const text = lastError.message.toLowerCase();
            if (
              text.includes("failed to fetch") ||
              text.includes("networkerror") ||
              text.includes("load failed")
            ) {
              sawUnreachableServer = true;
            }
          }
        }

        if (sawUnreachableServer) {
          throw new Error(SERVER_UNREACHABLE_ERROR);
        }
        if (lastError) {
          throw lastError;
        }
        throw new Error(SERVER_UNREACHABLE_ERROR);
      }

      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (isSending) return;

        const message = inputEl.value.trim();
        if (!message) return;

        isSending = true;
        inputEl.disabled = true;
        sendBtnEl.disabled = true;
        sendBtnEl.textContent = "Sending...";

        inputEl.value = "";
        addMessage("user", message);

        try {
          const reply = await sendMessage(message);
          setConnectionMode("online");
          offlineModeNotified = false;
          addMessage("bot", reply);
        } catch (error) {
          if (error instanceof Error && error.message === SERVER_UNREACHABLE_ERROR) {
            setConnectionMode("offline");
            if (!offlineModeNotified) {
              addMessage(
                "bot",
                "Server not reachable. Switched to offline mode. " +
                  "Run python app.py and open http://127.0.0.1:5000 for full mode."
              );
              offlineModeNotified = true;
            }
            addMessage("bot", getOfflineReply(message));
          } else {
            const text = error instanceof Error ? error.message : String(error);
            addMessage("bot", `Error: ${text}`);
          }
        } finally {
          isSending = false;
          inputEl.disabled = false;
          sendBtnEl.disabled = false;
          sendBtnEl.textContent = "Send";
          inputEl.focus();
        }
      });

      setConnectionMode("online");
      resetChat();
    </script>
  </body>
</html>
