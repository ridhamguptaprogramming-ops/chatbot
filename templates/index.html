<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Todo Chatbot</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #f6f2ea;
        --ink: #1e1b18;
        --brand: #1d7f68;
        --brand-dark: #145747;
        --panel: rgba(255, 255, 255, 0.78);
        --line: rgba(31, 29, 26, 0.12);
        --user: #e3f8f2;
        --bot: #fff7e5;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Space Grotesk", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 8% 12%, #ffe6ae 0, transparent 30%),
          radial-gradient(circle at 90% 4%, #c9efe4 0, transparent 32%),
          linear-gradient(145deg, #f8f4ed, #f2efe7 45%, #e9f0ea);
        display: grid;
        place-items: center;
        padding: 24px;
      }

      .orb {
        position: fixed;
        border-radius: 999px;
        filter: blur(48px);
        pointer-events: none;
        z-index: 0;
      }

      .orb.one {
        width: 280px;
        height: 280px;
        background: rgba(37, 183, 145, 0.22);
        top: -70px;
        right: 4vw;
      }

      .orb.two {
        width: 240px;
        height: 240px;
        background: rgba(255, 199, 89, 0.25);
        left: 4vw;
        bottom: -90px;
      }

      .shell {
        position: relative;
        z-index: 1;
        width: min(1120px, 100%);
        height: min(760px, 88vh);
        border: 1px solid var(--line);
        border-radius: 20px;
        background: var(--panel);
        backdrop-filter: blur(10px);
        display: grid;
        grid-template-rows: auto 1fr auto;
        overflow: hidden;
        box-shadow: 0 24px 58px rgba(35, 28, 18, 0.14);
      }

      .top {
        padding: 20px 22px;
        border-bottom: 1px solid var(--line);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
      }

      .title-wrap {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .badge {
        width: 34px;
        height: 34px;
        border-radius: 10px;
        background: linear-gradient(145deg, #24a185, #176352);
        display: grid;
        place-items: center;
        color: white;
        font-weight: 700;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.05rem, 2vw, 1.35rem);
      }

      .hint {
        margin: 0;
        opacity: 0.75;
        font-size: 0.9rem;
      }

      .top-actions {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .mode-pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 0.78rem;
        border: 1px solid var(--line);
        background: #f5f3ef;
      }

      .mode-pill.online {
        background: #ddf4ec;
        color: #0f5a49;
        border-color: rgba(15, 90, 73, 0.25);
      }

      .mode-pill.offline {
        background: #ffe6d7;
        color: #8a3c17;
        border-color: rgba(138, 60, 23, 0.25);
      }

      .messages {
        padding: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow-y: auto;
      }

      .workspace {
        min-height: 0;
        display: grid;
        grid-template-columns: minmax(0, 1.8fr) minmax(280px, 1fr);
        border-bottom: 1px solid var(--line);
      }

      .dashboard {
        border-left: 1px solid var(--line);
        padding: 14px 14px 12px;
        display: flex;
        flex-direction: column;
        min-height: 0;
        background: rgba(255, 255, 255, 0.5);
      }

      .dash-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 10px;
      }

      .dash-title {
        font-size: 0.9rem;
        font-weight: 700;
      }

      .dash-sync {
        display: block;
        margin-top: 2px;
        font-size: 0.72rem;
        opacity: 0.75;
      }

      .stat-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
        margin-bottom: 12px;
      }

      .stat-card {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 8px 9px;
        background: #fffdf8;
      }

      .stat-card span {
        display: block;
        font-size: 0.74rem;
        opacity: 0.8;
      }

      .stat-card strong {
        display: block;
        margin-top: 4px;
        font-size: 1rem;
      }

      .dash-subtitle {
        font-size: 0.82rem;
        font-weight: 700;
        margin: 0 0 8px;
      }

      .task-list {
        list-style: none;
        padding: 0;
        margin: 0;
        overflow-y: auto;
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .task-item {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 8px;
        background: #fffbf3;
      }

      .task-item-title {
        font-size: 0.84rem;
        font-weight: 600;
      }

      .task-item-meta {
        margin-top: 4px;
        font-size: 0.72rem;
        opacity: 0.82;
      }

      .msg {
        max-width: 78%;
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid var(--line);
        white-space: pre-wrap;
        line-height: 1.35;
        animation: rise 180ms ease;
      }

      .msg a {
        color: #0b5ea8;
        text-decoration: underline;
        word-break: break-all;
      }

      .msg.user {
        margin-left: auto;
        background: var(--user);
      }

      .msg.bot {
        margin-right: auto;
        background: var(--bot);
      }

      .composer {
        padding: 14px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
      }

      input {
        width: 100%;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 12px;
        padding: 12px 14px;
        font: inherit;
      }

      input:focus {
        outline: 2px solid #89c8ba;
        outline-offset: 1px;
      }

      button {
        border: none;
        border-radius: 12px;
        padding: 0 18px;
        font: inherit;
        font-weight: 600;
        color: white;
        background: linear-gradient(145deg, var(--brand), var(--brand-dark));
        cursor: pointer;
      }

      button:hover {
        filter: brightness(1.05);
      }

      .mini-btn {
        height: 34px;
        padding: 0 12px;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        border-radius: 10px;
        font-size: 0.82rem;
        font-weight: 600;
      }

      .mini-select {
        height: 34px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #ffffff;
        color: var(--ink);
        font: inherit;
        font-size: 0.82rem;
        padding: 0 10px;
      }

      .quick-actions {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .quick-btn {
        height: 30px;
        padding: 0 12px;
        border-radius: 999px;
        border: 1px solid var(--line);
        background: #fffaf0;
        color: #2b2a28;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .smart-replies {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .smart-btn {
        height: 30px;
        padding: 0 12px;
        border-radius: 999px;
        border: 1px dashed rgba(29, 127, 104, 0.5);
        background: #ebfff8;
        color: #145747;
        font-size: 0.8rem;
        font-weight: 600;
      }

      .typing-indicator {
        font-size: 0.84rem;
        opacity: 0.75;
        font-style: italic;
      }

      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      @media (max-width: 640px) {
        body {
          padding: 12px;
        }

        .shell {
          height: min(760px, 95vh);
          border-radius: 16px;
        }

        .workspace {
          grid-template-columns: 1fr;
        }

        .dashboard {
          border-left: none;
          border-top: 1px solid var(--line);
          max-height: 230px;
        }

        .msg {
          max-width: 88%;
        }
      }
    </style>
  </head>
  <body>
    <div class="orb one"></div>
    <div class="orb two"></div>

    <main class="shell">
      <header class="top">
        <div class="title-wrap">
          <div class="badge">T</div>
          <div>
            <h1>Todo Chatbot</h1>
            <p class="hint">Try: add buy milk /p:high /d:2026-03-10</p>
          </div>
        </div>
        <div class="top-actions">
          <select id="language-select" class="mini-select">
            <option value="en-US|English">English</option>
            <option value="hi-IN|Hindi">Hindi</option>
            <option value="en-IN|Hinglish">Hinglish</option>
            <option value="es-ES|Spanish">Spanish</option>
          </select>
          <button id="mic-btn" class="mini-btn" type="button">Mic</button>
          <button id="voice-toggle-btn" class="mini-btn" type="button">Voice Off</button>
          <span id="mode-indicator" class="mode-pill online">Online</span>
          <button id="clear-chat-btn" class="mini-btn" type="button">Clear chat</button>
        </div>
      </header>

      <div class="workspace">
        <section id="messages" class="messages"></section>
        <aside class="dashboard">
          <div class="dash-head">
            <span>
              <span class="dash-title">Live Dashboard</span>
              <span id="dashboard-sync" class="dash-sync">Waiting for first sync...</span>
            </span>
            <button id="refresh-state-btn" class="mini-btn" type="button">Refresh</button>
          </div>

          <div class="stat-grid">
            <div class="stat-card">
              <span>Total</span>
              <strong id="stat-total">0</strong>
            </div>
            <div class="stat-card">
              <span>Open</span>
              <strong id="stat-open">0</strong>
            </div>
            <div class="stat-card">
              <span>Done</span>
              <strong id="stat-done">0</strong>
            </div>
            <div class="stat-card">
              <span>Overdue</span>
              <strong id="stat-overdue">0</strong>
            </div>
          </div>

          <p class="dash-subtitle">Top Tasks</p>
          <ul id="dashboard-task-list" class="task-list">
            <li class="task-item">
              <div class="task-item-title">No tasks yet</div>
              <div class="task-item-meta">Add one to populate dashboard.</div>
            </li>
          </ul>
        </aside>
      </div>

      <footer class="composer">
        <form id="chat-form" class="row">
          <input
            id="chat-input"
            type="text"
            placeholder="Type a message..."
            autocomplete="off"
            required
          />
          <button id="send-btn" type="submit">Send</button>
        </form>
        <div class="quick-actions">
          <button type="button" class="quick-btn" data-prompt="help">help</button>
          <button type="button" class="quick-btn" data-prompt="list open">list open</button>
          <button type="button" class="quick-btn" data-prompt="stats">stats</button>
          <button type="button" class="quick-btn" data-prompt="web oats nutrition">
            web oats nutrition
          </button>
          <button
            type="button"
            class="quick-btn"
            data-prompt="suggest laptop under 800"
          >
            suggest laptop
          </button>
        </div>
        <div id="smart-replies" class="smart-replies"></div>
      </footer>
    </main>

    <script>
      const messagesEl = document.getElementById("messages");
      const formEl = document.getElementById("chat-form");
      const inputEl = document.getElementById("chat-input");
      const sendBtnEl = document.getElementById("send-btn");
      const modeIndicatorEl = document.getElementById("mode-indicator");
      const clearChatBtnEl = document.getElementById("clear-chat-btn");
      const refreshStateBtnEl = document.getElementById("refresh-state-btn");
      const languageSelectEl = document.getElementById("language-select");
      const micBtnEl = document.getElementById("mic-btn");
      const voiceToggleBtnEl = document.getElementById("voice-toggle-btn");
      const smartRepliesEl = document.getElementById("smart-replies");
      const statTotalEl = document.getElementById("stat-total");
      const statOpenEl = document.getElementById("stat-open");
      const statDoneEl = document.getElementById("stat-done");
      const statOverdueEl = document.getElementById("stat-overdue");
      const dashboardTaskListEl = document.getElementById("dashboard-task-list");
      const dashboardSyncEl = document.getElementById("dashboard-sync");
      const quickBtns = document.querySelectorAll(".quick-btn");

      const OFFLINE_TODOS_KEY = "todo_chatbot_offline_todos_v1";
      const SESSION_KEY = "todo_chatbot_session_id_v1";
      const LANGUAGE_KEY = "todo_chatbot_language_v1";
      const VOICE_KEY = "todo_chatbot_voice_enabled_v1";
      const CHAT_HISTORY_KEY = "todo_chatbot_chat_history_v1";
      const SERVER_UNREACHABLE_ERROR = "__SERVER_UNREACHABLE__";
      const DASHBOARD_POLL_MS = 7000;

      const savedLanguage = localStorage.getItem(LANGUAGE_KEY);
      if (
        savedLanguage &&
        [...languageSelectEl.options].some((option) => option.value === savedLanguage)
      ) {
        languageSelectEl.value = savedLanguage;
      }

      let isSending = false;
      let isListening = false;
      let shouldSubmitAfterListen = false;
      let offlineModeNotified = false;
      let recognition = null;
      let typingIndicatorEl = null;
      let ttsEnabled = localStorage.getItem(VOICE_KEY) === "1";
      let dashboardPollHandle = null;
      let dashboardRefreshInFlight = false;
      let stateEndpointSupported = null;
      const sessionId = getOrCreateSessionId();
      const offlineTodos = loadOfflineTodos();
      let chatHistory = loadChatHistory();

      function getOrCreateSessionId() {
        const existing = localStorage.getItem(SESSION_KEY);
        if (existing) return existing;
        const generated =
          typeof crypto !== "undefined" && crypto.randomUUID
            ? crypto.randomUUID()
            : `session-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        localStorage.setItem(SESSION_KEY, generated);
        return generated;
      }

      function getLanguageSetting() {
        const [speechCode, name] = (languageSelectEl.value || "en-US|English").split("|");
        return {
          speechCode: speechCode || "en-US",
          name: name || "English",
        };
      }

      function setConnectionMode(mode) {
        if (mode === "offline") {
          modeIndicatorEl.textContent = "Offline";
          modeIndicatorEl.classList.remove("online");
          modeIndicatorEl.classList.add("offline");
          return;
        }
        modeIndicatorEl.textContent = "Online";
        modeIndicatorEl.classList.remove("offline");
        modeIndicatorEl.classList.add("online");
      }

      function setDashboardSyncLabel(text) {
        dashboardSyncEl.textContent = text;
      }

      function formatSyncTime(dateObj) {
        return dateObj.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      }

      function setVoiceToggleLabel() {
        voiceToggleBtnEl.textContent = ttsEnabled ? "Voice On" : "Voice Off";
      }

      function updateMicButton() {
        micBtnEl.textContent = isListening ? "Stop Mic" : "Mic";
      }

      function initSpeechRecognition() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
          micBtnEl.disabled = true;
          micBtnEl.textContent = "Mic N/A";
          return;
        }

        recognition = new SpeechRecognition();
        recognition.lang = getLanguageSetting().speechCode;
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        recognition.continuous = false;

        recognition.onstart = () => {
          isListening = true;
          updateMicButton();
        };

        recognition.onresult = (event) => {
          const transcript = Array.from(event.results)
            .map((item) => item[0].transcript)
            .join(" ")
            .trim();
          inputEl.value = transcript;
        };

        recognition.onerror = () => {
          isListening = false;
          shouldSubmitAfterListen = false;
          updateMicButton();
        };

        recognition.onend = () => {
          isListening = false;
          updateMicButton();
          if (shouldSubmitAfterListen) {
            shouldSubmitAfterListen = false;
            if (inputEl.value.trim() && !isSending) {
              formEl.requestSubmit();
            }
          }
        };
      }

      function speakBotText(text) {
        if (!ttsEnabled) return;
        if (!("speechSynthesis" in window)) return;

        const spoken = text.replace(/https?:\/\/\S+/g, "").trim();
        if (!spoken) return;

        const utterance = new SpeechSynthesisUtterance(spoken);
        const language = getLanguageSetting().speechCode;
        utterance.lang = language;

        const voices = window.speechSynthesis.getVoices();
        const languageRoot = language.split("-")[0].toLowerCase();
        const matchingVoice = voices.find((voice) =>
          voice.lang.toLowerCase().startsWith(languageRoot)
        );
        if (matchingVoice) {
          utterance.voice = matchingVoice;
        }

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      }

      function normalizeOfflinePriority(rawValue) {
        const value = String(rawValue || "").trim().toLowerCase();
        if (["low", "medium", "high"].includes(value)) return value;
        return "medium";
      }

      function normalizeOfflineDueDate(rawValue) {
        const value = String(rawValue || "").trim();
        if (!value) return null;
        if (!/^\d{4}-\d{2}-\d{2}$/.test(value)) return null;
        const testDate = new Date(`${value}T00:00:00`);
        if (Number.isNaN(testDate.getTime())) return null;
        return value;
      }

      function loadOfflineTodos() {
        try {
          const raw = localStorage.getItem(OFFLINE_TODOS_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed
            .filter((item) => item && typeof item.text === "string")
            .map((item) => ({
              text: item.text.trim(),
              done: Boolean(item.done),
              priority: normalizeOfflinePriority(item.priority),
              due_date: normalizeOfflineDueDate(item.due_date),
            }))
            .filter((item) => item.text.length > 0);
        } catch {
          return [];
        }
      }

      function saveOfflineTodos() {
        try {
          localStorage.setItem(OFFLINE_TODOS_KEY, JSON.stringify(offlineTodos));
        } catch {
          // Ignore storage failures and keep chat available.
        }
      }

      function loadChatHistory() {
        try {
          const raw = localStorage.getItem(CHAT_HISTORY_KEY);
          if (!raw) return [];
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) return [];
          return parsed
            .filter((item) => item && (item.role === "user" || item.role === "bot"))
            .map((item) => ({
              role: item.role,
              text: String(item.text || ""),
              ts: Number(item.ts || Date.now()),
            }))
            .filter((item) => item.text.trim().length > 0)
            .slice(-80);
        } catch {
          return [];
        }
      }

      function saveChatHistory() {
        try {
          localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(chatHistory.slice(-80)));
        } catch {
          // Ignore persistence failure.
        }
      }

      function escapeHtml(value) {
        return value
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function formatTextWithLinks(text) {
        const escaped = escapeHtml(text);
        const withLinks = escaped.replace(
          /(https?:\/\/[^\s]+)/g,
          '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>'
        );
        return withLinks.replaceAll("\n", "<br>");
      }

      function addMessage(role, text, options = {}) {
        const persist = options.persist !== false;
        const speak = options.speak !== false;

        const message = document.createElement("div");
        message.className = `msg ${role}`;
        if (role === "bot") {
          message.innerHTML = formatTextWithLinks(text);
          if (speak) speakBotText(text);
        } else {
          message.textContent = text;
        }
        messagesEl.appendChild(message);
        messagesEl.scrollTop = messagesEl.scrollHeight;

        if (persist) {
          chatHistory.push({ role, text, ts: Date.now() });
          chatHistory = chatHistory.slice(-80);
          saveChatHistory();
        }
      }

      function showTypingIndicator() {
        if (typingIndicatorEl) return;
        typingIndicatorEl = document.createElement("div");
        typingIndicatorEl.className = "msg bot typing-indicator";
        typingIndicatorEl.textContent = "Typing...";
        messagesEl.appendChild(typingIndicatorEl);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function hideTypingIndicator() {
        if (!typingIndicatorEl) return;
        typingIndicatorEl.remove();
        typingIndicatorEl = null;
      }

      function buildSmartReplies(botText, lastUserText = "") {
        const source = `${botText} ${lastUserText}`.toLowerCase();
        if (source.includes("live web results for")) {
          return ["web banana calories", "web best whey protein", "search task groceries"];
        }
        if (source.includes("online links for")) {
          return ["best budget option", "compare top 3", "suggest for students"];
        }
        if (source.includes("task stats")) {
          return ["list open", "list overdue", "add follow up /p:high"];
        }
        if (source.includes("no tasks yet")) {
          return ["add buy groceries /p:high", "help", "suggest laptop under 800"];
        }
        if (source.includes("invalid task number")) {
          return ["list", "help", "stats"];
        }
        if (source.includes("commands:")) {
          return ["add call client /p:high", "list open", "suggest headphones"];
        }
        return ["help", "list open", "stats"];
      }

      function renderSmartReplies(botText, lastUserText = "") {
        const suggestions = buildSmartReplies(botText, lastUserText);
        smartRepliesEl.innerHTML = "";
        suggestions.forEach((text) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "smart-btn";
          button.textContent = text;
          button.addEventListener("click", () => {
            if (isSending) return;
            inputEl.value = text;
            inputEl.focus();
            formEl.requestSubmit();
          });
          smartRepliesEl.appendChild(button);
        });
      }

      function hydrateChatFromHistory() {
        messagesEl.innerHTML = "";
        hideTypingIndicator();

        if (!chatHistory.length) {
          const welcome = "Ready. Use voice, type, or tap suggestions.";
          addMessage("bot", welcome, { speak: false });
          renderSmartReplies(welcome);
          return;
        }

        for (const item of chatHistory) {
          addMessage(item.role, item.text, { persist: false, speak: false });
        }

        const lastBot = [...chatHistory].reverse().find((item) => item.role === "bot");
        const lastUser = [...chatHistory].reverse().find((item) => item.role === "user");
        renderSmartReplies(lastBot ? lastBot.text : "help", lastUser ? lastUser.text : "");
      }

      function resetChat(clearHistory = false) {
        if (clearHistory) {
          chatHistory = [];
          saveChatHistory();
        }
        hydrateChatFromHistory();
      }

      function formatOfflineTodoLine(item, index) {
        const priority = normalizeOfflinePriority(item.priority).toUpperCase();
        const dueValue = normalizeOfflineDueDate(item.due_date);
        const dueSuffix = dueValue ? ` (due: ${dueValue})` : "";
        return `${index + 1}. [${item.done ? "x" : " "}] [${priority}] ${item.text}${dueSuffix}`;
      }

      function getOfflineState() {
        const total = offlineTodos.length;
        const done = offlineTodos.filter((item) => item.done).length;
        const open = total - done;
        const overdue = offlineTodos.filter((item) => {
          const due = normalizeOfflineDueDate(item.due_date);
          return !item.done && due && due < new Date().toISOString().slice(0, 10);
        }).length;
        return {
          tasks: offlineTodos.map((item, idx) => ({
            id: idx + 1,
            text: item.text,
            done: Boolean(item.done),
            priority: normalizeOfflinePriority(item.priority),
            due_date: normalizeOfflineDueDate(item.due_date),
          })),
          stats: {
            total,
            open,
            done,
            overdue,
            high: offlineTodos.filter(
              (item) => normalizeOfflinePriority(item.priority) === "high"
            ).length,
          },
        };
      }

      function renderDashboardFromState(state) {
        const stats = (state && state.stats) || {};
        const tasks = (state && Array.isArray(state.tasks) ? state.tasks : []);

        statTotalEl.textContent = String(stats.total || 0);
        statOpenEl.textContent = String(stats.open || 0);
        statDoneEl.textContent = String(stats.done || 0);
        statOverdueEl.textContent = String(stats.overdue || 0);

        const priorityRank = { high: 0, medium: 1, low: 2 };
        const sorted = [...tasks]
          .sort((a, b) => {
            if (Boolean(a.done) !== Boolean(b.done)) return a.done ? 1 : -1;
            const aDue = a.due_date || "9999-12-31";
            const bDue = b.due_date || "9999-12-31";
            if (aDue !== bDue) return aDue.localeCompare(bDue);
            const aPriority = priorityRank[a.priority] ?? 3;
            const bPriority = priorityRank[b.priority] ?? 3;
            if (aPriority !== bPriority) return aPriority - bPriority;
            return String(a.text || "").localeCompare(String(b.text || ""));
          })
          .slice(0, 6);

        dashboardTaskListEl.innerHTML = "";
        if (!sorted.length) {
          dashboardTaskListEl.innerHTML =
            '<li class="task-item"><div class="task-item-title">No tasks yet</div><div class="task-item-meta">Add one to populate dashboard.</div></li>';
          return;
        }

        sorted.forEach((task) => {
          const item = document.createElement("li");
          item.className = "task-item";
          const status = task.done ? "Done" : "Open";
          const due = task.due_date ? ` | due ${task.due_date}` : "";
          item.innerHTML = `
            <div class="task-item-title">#${task.id} ${escapeHtml(task.text || "")}</div>
            <div class="task-item-meta">${status} | ${String(task.priority || "medium").toUpperCase()}${due}</div>
          `;
          dashboardTaskListEl.appendChild(item);
        });
      }

      function normalizeOfflinePriorityFilter(rawValue) {
        const value = String(rawValue || "").toLowerCase();
        return ["low", "medium", "high"].includes(value) ? value : "medium";
      }

      function renderOfflineList(filterMode) {
        if (!offlineTodos.length) {
          return "No tasks yet. Add one with: add <task>";
        }

        const mode = (filterMode || "all").toLowerCase();
        const today = new Date().toISOString().slice(0, 10);

        const matches = offlineTodos
          .map((item, index) => ({ item, index }))
          .filter((entry) => {
            const item = entry.item;
            const done = Boolean(item.done);
            const priority = normalizeOfflinePriorityFilter(item.priority);
            const dueValue = normalizeOfflineDueDate(item.due_date);

            if (mode === "all") return true;
            if (mode === "open") return !done;
            if (mode === "done") return done;
            if (["low", "medium", "high"].includes(mode)) return priority === mode;
            if (mode === "today") return dueValue === today;
            if (mode === "overdue") return !done && Boolean(dueValue) && dueValue < today;
            return true;
          });

        if (!matches.length) {
          return `No tasks found for filter '${mode}'.`;
        }

        return matches
          .map((entry) => formatOfflineTodoLine(entry.item, entry.index))
          .join("\n");
      }

      function extractProductQuery(text) {
        const trimmed = text.trim();
        const lower = trimmed.toLowerCase();
        const patterns = [
          /^(?:buy|get|purchase|order)\s+(.+)$/i,
          /^(?:recommend|suggest)\s+(?:me\s+)?(?:a|an|the\s+)?(.+)$/i,
          /^(?:best)\s+(.+)$/i,
          /^i\s+(?:want|need)\s+to\s+buy\s+(.+)$/i,
          /^what\s+is\s+the\s+best\s+(.+)$/i,
          /^which\s+(.+?)\s+should\s+i\s+buy\??$/i,
        ];

        for (const pattern of patterns) {
          const match = trimmed.match(pattern);
          if (!match || !match[1]) continue;
          const candidate = match[1].trim().replace(/[.?!]+$/, "");
          if (candidate) return candidate;
        }

        if (
          ["recommend", "suggest", "best", "buy", "purchase"].some((keyword) =>
            lower.includes(keyword)
          )
        ) {
          return trimmed
            .replace(/^(can you|please|hey|hi|hello|could you)\s+/i, "")
            .trim()
            .replace(/[.?!]+$/, "");
        }
        return null;
      }

      function buildProductLinks(query) {
        const encoded = encodeURIComponent(query);
        return [
          `Amazon: https://www.amazon.com/s?k=${encoded}`,
          `Walmart: https://www.walmart.com/search?q=${encoded}`,
          `Best Buy: https://www.bestbuy.com/site/searchpage.jsp?st=${encoded}`,
          `Target: https://www.target.com/s?searchTerm=${encoded}`,
        ];
      }

      function getOfflineReply(message) {
        const text = message.trim();
        const lower = text.toLowerCase();

        if (lower === "help" || lower === "commands") {
          return (
            "Commands:\n" +
            "- add <task> [/p:low|medium|high] [/d:YYYY-MM-DD]\n" +
            "- list [all|open|done|high|medium|low|today|overdue]\n" +
            "- done <number>\n" +
            "- undone <number>\n" +
            "- delete <number>\n\n" +
            "- priority <number> <low|medium|high>\n" +
            "- due <number> <YYYY-MM-DD|none>\n" +
            "- search <text> (todo first, then web)\n" +
            "- search task <text>\n" +
            "- clear done\n" +
            "- clear all\n" +
            "- stats\n\n" +
            "Web:\n" +
            "- web <query>\n" +
            "- google <query>\n\n" +
            "Product queries:\n" +
            "- suggest laptop under 800\n" +
            "- best phone for gaming\n" +
            "- buy running shoes"
          );
        }

        const addMatch = text.match(/^(add|new|todo)\s+(.+)$/i);
        if (addMatch) {
          const rawTask = addMatch[2].trim();
          let priority = "medium";
          let dueDate = null;

          const priorityMatch = rawTask.match(/(?:^|\s)\/p:(low|medium|high)\b/i);
          if (priorityMatch) priority = priorityMatch[1].toLowerCase();

          const dueMatch = rawTask.match(/(?:^|\s)\/d:(\d{4}-\d{2}-\d{2}|none)\b/i);
          if (dueMatch) {
            const rawDue = dueMatch[1].toLowerCase();
            if (rawDue !== "none") {
              const normalizedDue = normalizeOfflineDueDate(rawDue);
              if (!normalizedDue) return "Invalid due date format. Use /d:YYYY-MM-DD";
              dueDate = normalizedDue;
            }
          }

          const cleanedTask = rawTask
            .replace(/(?:^|\s)\/p:(low|medium|high)\b/gi, " ")
            .replace(/(?:^|\s)\/d:(\d{4}-\d{2}-\d{2}|none)\b/gi, " ")
            .replace(/\s+/g, " ")
            .trim();

          if (!cleanedTask) {
            return (
              "Task text is required. Example:\n" +
              "add buy groceries /p:high /d:2026-03-10"
            );
          }

          offlineTodos.push({
            text: cleanedTask,
            done: false,
            priority,
            due_date: dueDate,
          });
          saveOfflineTodos();
          const extras = [`priority=${priority}`];
          if (dueDate) extras.push(`due=${dueDate}`);
          return `Added task #${offlineTodos.length}: ${cleanedTask} (${extras.join(", ")})`;
        }

        const listMatch = lower.match(
          /^(?:list|tasks|todos|show tasks|show todos)(?:\s+(all|open|done|high|medium|low|today|overdue))?$/
        );
        if (listMatch) return renderOfflineList(listMatch[1] || "all");

        const doneMatch = lower.match(/^(done|complete|finish)\s+(\d+)$/);
        if (doneMatch) {
          const index = Number(doneMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          offlineTodos[index - 1].done = true;
          saveOfflineTodos();
          return `Marked task #${index} as done.`;
        }

        const undoneMatch = lower.match(/^(undone|undo|reopen)\s+(\d+)$/);
        if (undoneMatch) {
          const index = Number(undoneMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          offlineTodos[index - 1].done = false;
          saveOfflineTodos();
          return `Marked task #${index} as not done.`;
        }

        const deleteMatch = lower.match(/^(delete|remove)\s+(\d+)$/);
        if (deleteMatch) {
          const index = Number(deleteMatch[2]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const removed = offlineTodos.splice(index - 1, 1)[0];
          saveOfflineTodos();
          return `Deleted task #${index}: ${removed.text}`;
        }

        const priorityMatch = lower.match(
          /^(?:priority|set priority)\s+(\d+)\s+(low|medium|high)$/
        );
        if (priorityMatch) {
          const index = Number(priorityMatch[1]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const value = priorityMatch[2];
          offlineTodos[index - 1].priority = value;
          saveOfflineTodos();
          return `Updated priority of task #${index} to ${value}.`;
        }

        const dueMatch = lower.match(
          /^(?:due|set due)\s+(\d+)\s+(\d{4}-\d{2}-\d{2}|none)$/
        );
        if (dueMatch) {
          const index = Number(dueMatch[1]);
          if (index < 1 || index > offlineTodos.length) return "Invalid task number.";
          const value = dueMatch[2];
          if (value === "none") {
            offlineTodos[index - 1].due_date = null;
            saveOfflineTodos();
            return `Removed due date from task #${index}.`;
          }
          const normalizedDue = normalizeOfflineDueDate(value);
          if (!normalizedDue) return "Invalid due date format. Use YYYY-MM-DD.";
          offlineTodos[index - 1].due_date = normalizedDue;
          saveOfflineTodos();
          return `Updated due date of task #${index} to ${normalizedDue}.`;
        }

        const searchMatch = text.match(/^(search|find)\s+(.+)$/i);
        if (searchMatch) {
          const query = searchMatch[2].trim().toLowerCase();
          if (!query) return "Please provide search text.";
          const rows = offlineTodos
            .map((item, index) => ({ item, index }))
            .filter((entry) => entry.item.text.toLowerCase().includes(query))
            .map((entry) => formatOfflineTodoLine(entry.item, entry.index));
          if (!rows.length) return "No matching tasks found.";
          return rows.join("\n");
        }

        const webMatch = text.match(
          /^(web|google|search web|search online|find online|look up|lookup)\s+(.+)$/i
        );
        if (webMatch) {
          const query = webMatch[2].trim();
          if (!query) return "Please provide a web query.";
          return (
            "Live web search needs server mode.\n" +
            `Google: https://www.google.com/search?q=${encodeURIComponent(query)}`
          );
        }

        if (["clear done", "clear completed", "remove done", "remove completed"].includes(lower)) {
          const before = offlineTodos.length;
          const remaining = offlineTodos.filter((item) => !item.done);
          offlineTodos.length = 0;
          offlineTodos.push(...remaining);
          saveOfflineTodos();
          return `Removed ${before - remaining.length} completed task(s).`;
        }

        if (["clear all", "reset", "delete all"].includes(lower)) {
          const count = offlineTodos.length;
          offlineTodos.length = 0;
          saveOfflineTodos();
          return `Cleared all tasks (${count}).`;
        }

        if (["stats", "summary"].includes(lower)) {
          const total = offlineTodos.length;
          const done = offlineTodos.filter((item) => item.done).length;
          const open = total - done;
          const high = offlineTodos.filter(
            (item) => normalizeOfflinePriority(item.priority) === "high"
          ).length;
          const today = new Date().toISOString().slice(0, 10);
          const overdue = offlineTodos.filter((item) => {
            const dueValue = normalizeOfflineDueDate(item.due_date);
            return !item.done && Boolean(dueValue) && dueValue < today;
          }).length;
          return (
            "Task stats:\n" +
            `- Total: ${total}\n` +
            `- Open: ${open}\n` +
            `- Done: ${done}\n` +
            `- High priority: ${high}\n` +
            `- Overdue (open): ${overdue}`
          );
        }

        const productQuery = extractProductQuery(text);
        if (productQuery) {
          return (
            `Online links for '${productQuery}':\n` +
            `${buildProductLinks(productQuery).map((line) => `- ${line}`).join("\n")}`
          );
        }

        if (["hi", "hello", "hey"].some((greeting) => lower.includes(greeting))) {
          return "Hi! I can manage todos. Try: add buy milk /p:high";
        }
        if (lower.includes("name")) return "I am your Todo Chatbot.";
        if (lower.includes("how are you")) return "Doing well. Want to add a task?";

        return (
          "I can help with todos, product links, and web search. Use:\n" +
          "- add <task> [/p:high] [/d:YYYY-MM-DD]\n" +
          "- list [open|done|today|overdue]\n" +
          "- done <number>\n" +
          "- undone <number>\n" +
          "- delete <number>\n" +
          "- priority <number> <low|medium|high>\n" +
          "- due <number> <YYYY-MM-DD|none>\n" +
          "- search <text>\n" +
          "- search task <text>\n" +
          "- clear done\n" +
          "- clear all\n" +
          "- stats\n" +
          "- suggest <product>\n" +
          "- web <query>"
        );
      }

      function buildApiEndpoints() {
        const endpoints = ["/api/chat"];
        const protocol = window.location.protocol;
        const host = window.location.hostname || "";

        if (
          protocol === "http:" &&
          (host === "127.0.0.1" || host === "localhost")
        ) {
          endpoints.push(`http://${host}:5000/api/chat`);
        }

        if (protocol !== "https:") {
          endpoints.push("http://127.0.0.1:5000/api/chat");
          endpoints.push("http://localhost:5000/api/chat");
        }

        return Array.from(new Set(endpoints));
      }

      function getStateEndpoint(chatEndpoint) {
        return chatEndpoint.replace("/api/chat", "/api/state");
      }

      function parseTasksFromListReply(replyText) {
        const text = String(replyText || "").trim();
        if (!text || text.toLowerCase().includes("no tasks yet")) {
          return [];
        }

        const lines = text.split("\n").map((line) => line.trim()).filter(Boolean);
        const tasks = [];

        for (const line of lines) {
          const advanced = line.match(
            /^(\d+)\.\s+\[(x| )\]\s+\[(LOW|MEDIUM|HIGH)\]\s+(.+?)(?:\s+\(due:\s+(\d{4}-\d{2}-\d{2})\))?$/i
          );
          if (advanced) {
            tasks.push({
              id: Number(advanced[1]),
              done: advanced[2].toLowerCase() === "x",
              priority: advanced[3].toLowerCase(),
              text: advanced[4].trim(),
              due_date: advanced[5] || null,
            });
            continue;
          }

          const basic = line.match(/^(\d+)\.\s+\[(x| )\]\s+(.+)$/i);
          if (basic) {
            tasks.push({
              id: Number(basic[1]),
              done: basic[2].toLowerCase() === "x",
              priority: "medium",
              text: basic[3].trim(),
              due_date: null,
            });
          }
        }

        return tasks;
      }

      function parseStatsFromReply(replyText) {
        const text = String(replyText || "");
        const total = text.match(/- Total:\s*(\d+)/i);
        const open = text.match(/- Open:\s*(\d+)/i);
        const done = text.match(/- Done:\s*(\d+)/i);
        const high = text.match(/- High priority:\s*(\d+)/i);
        const overdue = text.match(/- Overdue \(open\):\s*(\d+)/i);

        if (!total && !open && !done) {
          return null;
        }

        return {
          total: Number(total?.[1] || 0),
          open: Number(open?.[1] || 0),
          done: Number(done?.[1] || 0),
          high: Number(high?.[1] || 0),
          overdue: Number(overdue?.[1] || 0),
        };
      }

      function buildStateFromFallbackReplies(listReply, statsReply) {
        const tasks = parseTasksFromListReply(listReply);
        const stats =
          parseStatsFromReply(statsReply) ||
          {
            total: tasks.length,
            open: tasks.filter((task) => !task.done).length,
            done: tasks.filter((task) => task.done).length,
            high: tasks.filter((task) => task.priority === "high").length,
            overdue: tasks.filter((task) => {
              const due = task.due_date;
              return !task.done && due && due < new Date().toISOString().slice(0, 10);
            }).length,
          };

        return { tasks, stats };
      }

      async function parseResponse(response) {
        const contentType = response.headers.get("content-type") || "";
        const rawText = await response.text();
        if (contentType.includes("application/json")) {
          try {
            return { payload: JSON.parse(rawText || "{}"), plainText: "" };
          } catch {
            return { payload: {}, plainText: rawText.trim() };
          }
        }
        return { payload: {}, plainText: rawText.trim() };
      }

      async function sendToEndpoint(endpoint, message, activeSessionId, languageName) {
        const query = new URLSearchParams({
          message,
          session_id: activeSessionId,
          language: languageName,
        });
        const getResponse = await fetch(`${endpoint}?${query.toString()}`);

        let response = getResponse;
        if (getResponse.status === 405) {
          response = await fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              message,
              session_id: activeSessionId,
              language: languageName,
            }),
          });
        }

        const parsed = await parseResponse(response);
        return { response, ...parsed };
      }

      function looksLikeMissingApi(errorText) {
        const text = (errorText || "").toLowerCase();
        return (
          text.includes("cannot get /api/chat") ||
          text.includes("cannot post /api/chat")
        );
      }

      async function fetchStateFromServer() {
        const endpoints = buildApiEndpoints();
        for (const endpoint of endpoints) {
          try {
            const stateEndpoint = getStateEndpoint(endpoint);
            const response = await fetch(stateEndpoint);
            const { payload } = await parseResponse(response);
            if (response.ok && payload && payload.stats) {
              return payload;
            }
          } catch {
            // Try next endpoint.
          }
        }
        throw new Error(SERVER_UNREACHABLE_ERROR);
      }

      async function fetchStateViaChatFallback() {
        const endpoints = buildApiEndpoints();
        const languageName = getLanguageSetting().name;

        for (const endpoint of endpoints) {
          try {
            const listResult = await sendToEndpoint(
              endpoint,
              "list all",
              sessionId,
              languageName
            );
            if (!listResult.response.ok) {
              continue;
            }

            const statsResult = await sendToEndpoint(
              endpoint,
              "stats",
              sessionId,
              languageName
            );
            if (!statsResult.response.ok) {
              continue;
            }

            const listReply = listResult.payload.reply || listResult.plainText || "";
            const statsReply = statsResult.payload.reply || statsResult.plainText || "";
            return buildStateFromFallbackReplies(listReply, statsReply);
          } catch {
            // Try next endpoint.
          }
        }

        throw new Error(SERVER_UNREACHABLE_ERROR);
      }

      async function sendMessage(message) {
        const endpoints = buildApiEndpoints();
        const languageName = getLanguageSetting().name;
        let lastError = null;
        let sawUnreachableServer = false;

        for (const endpoint of endpoints) {
          try {
            const { response, payload, plainText } = await sendToEndpoint(
              endpoint,
              message,
              sessionId,
              languageName
            );

            if (response.ok && typeof payload.reply === "string") {
              return {
                reply: payload.reply,
                state: payload.state || null,
              };
            }

            const errorText =
              payload.error || plainText || `Request failed (${response.status})`;

            if (
              response.status === 404 ||
              response.status === 405 ||
              looksLikeMissingApi(errorText)
            ) {
              sawUnreachableServer = true;
              lastError = new Error(errorText);
              continue;
            }

            throw new Error(errorText);
          } catch (error) {
            lastError = error instanceof Error ? error : new Error(String(error));
            const text = lastError.message.toLowerCase();
            if (
              text.includes("failed to fetch") ||
              text.includes("networkerror") ||
              text.includes("load failed")
            ) {
              sawUnreachableServer = true;
            }
          }
        }

        if (sawUnreachableServer) {
          throw new Error(SERVER_UNREACHABLE_ERROR);
        }
        if (lastError) {
          throw lastError;
        }
        throw new Error(SERVER_UNREACHABLE_ERROR);
      }

      async function refreshDashboard(onlineOnly = false) {
        if (dashboardRefreshInFlight) {
          return null;
        }
        dashboardRefreshInFlight = true;

        try {
          const state = await fetchStateFromServer();
          stateEndpointSupported = true;
          setConnectionMode("online");
          renderDashboardFromState(state);
          setDashboardSyncLabel(`Synced at ${formatSyncTime(new Date())}`);
          return state;
        } catch (stateError) {
          try {
            const fallbackState = await fetchStateViaChatFallback();
            stateEndpointSupported = false;
            setConnectionMode("online");
            renderDashboardFromState(fallbackState);
            setDashboardSyncLabel(`Synced via fallback at ${formatSyncTime(new Date())}`);
            return fallbackState;
          } catch (fallbackError) {
            if (!onlineOnly) {
              renderDashboardFromState(getOfflineState());
              setDashboardSyncLabel("Offline data");
            }
            throw fallbackError;
          }
        } finally {
          dashboardRefreshInFlight = false;
        }
      }

      async function pollDashboard() {
        if (isSending || document.hidden) return;
        if (stateEndpointSupported === false) return;
        try {
          const state = await fetchStateFromServer();
          stateEndpointSupported = true;
          setConnectionMode("online");
          renderDashboardFromState(state);
          setDashboardSyncLabel(`Synced at ${formatSyncTime(new Date())}`);
        } catch {
          if (stateEndpointSupported === false) return;
          setConnectionMode("offline");
          setDashboardSyncLabel("Server unreachable");
        }
      }

      function startDashboardPolling() {
        if (dashboardPollHandle) return;
        dashboardPollHandle = setInterval(pollDashboard, DASHBOARD_POLL_MS);
      }

      clearChatBtnEl.addEventListener("click", () => {
        resetChat(true);
        inputEl.focus();
      });

      refreshStateBtnEl.addEventListener("click", async () => {
        if (isSending) return;
        try {
          await refreshDashboard(true);
        } catch {
          setConnectionMode("offline");
          renderDashboardFromState(getOfflineState());
          setDashboardSyncLabel("Offline data");
        }
      });

      languageSelectEl.addEventListener("change", () => {
        localStorage.setItem(LANGUAGE_KEY, languageSelectEl.value);
        if (recognition) {
          recognition.lang = getLanguageSetting().speechCode;
        }
      });

      voiceToggleBtnEl.addEventListener("click", () => {
        ttsEnabled = !ttsEnabled;
        localStorage.setItem(VOICE_KEY, ttsEnabled ? "1" : "0");
        setVoiceToggleLabel();
      });

      micBtnEl.addEventListener("click", () => {
        if (!recognition) return;
        if (isListening) {
          shouldSubmitAfterListen = false;
          recognition.stop();
          return;
        }
        shouldSubmitAfterListen = true;
        recognition.lang = getLanguageSetting().speechCode;
        recognition.start();
      });

      quickBtns.forEach((button) => {
        button.addEventListener("click", () => {
          if (isSending) return;
          inputEl.value = button.dataset.prompt || "";
          inputEl.focus();
          formEl.requestSubmit();
        });
      });

      formEl.addEventListener("submit", async (event) => {
        event.preventDefault();
        if (isSending) return;

        const message = inputEl.value.trim();
        if (!message) return;

        isSending = true;
        inputEl.disabled = true;
        sendBtnEl.disabled = true;
        sendBtnEl.textContent = "Sending...";

        inputEl.value = "";
        addMessage("user", message);
        showTypingIndicator();

        try {
          const result = await sendMessage(message);
          setConnectionMode("online");
          offlineModeNotified = false;
          hideTypingIndicator();
          addMessage("bot", result.reply);
          renderSmartReplies(result.reply, message);
          if (result.state) {
            renderDashboardFromState(result.state);
            setDashboardSyncLabel(`Synced at ${formatSyncTime(new Date())}`);
          } else {
            await refreshDashboard(true);
          }
        } catch (error) {
          hideTypingIndicator();
          if (error instanceof Error && error.message === SERVER_UNREACHABLE_ERROR) {
            setConnectionMode("offline");
            if (!offlineModeNotified) {
              addMessage(
                "bot",
                "Server not reachable. Switched to offline mode. " +
                  "Run python3 app.py and open http://127.0.0.1:5000 for full mode."
              );
              offlineModeNotified = true;
            }
            const offlineReply = getOfflineReply(message);
            addMessage("bot", offlineReply);
            renderSmartReplies(offlineReply, message);
            renderDashboardFromState(getOfflineState());
            setDashboardSyncLabel("Offline data");
          } else {
            const text = error instanceof Error ? error.message : String(error);
            addMessage("bot", `Error: ${text}`);
          }
        } finally {
          isSending = false;
          inputEl.disabled = false;
          sendBtnEl.disabled = false;
          sendBtnEl.textContent = "Send";
          inputEl.focus();
        }
      });

      setConnectionMode("online");
      setVoiceToggleLabel();
      initSpeechRecognition();
      updateMicButton();
      hydrateChatFromHistory();
      startDashboardPolling();
      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          pollDashboard();
        }
      });
      refreshDashboard().catch(() => {
        setConnectionMode("offline");
        setDashboardSyncLabel("Offline data");
      });
    </script>
  </body>
</html>
